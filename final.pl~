#!/usr/bin/perl

our %moviesPresent = (); #key: actor.  Value: movies that the actor appears in
our %connectedActors = (); #search this in the search algorithm
our @pathActors = (); # will be an array of arrays; keep track of all the paths found from KB

while(@ARGV) {
  my $filename = shift(@ARGV);
  open($FH, "zcat $filename |")
    or die "cannot open $filename";
  my $current_actor = "";
  while(<$FH>) {
    my @movies = ();
    if ($_ =~ /^([^\t]+)\t.*/) {  # capture the actor's name (don't come here unless the line starts with the actor's name)
      $current_actor = $1; 
    }
    if ($_ =~ /^[^\t]*\t* ( .*?[)] )/x) {
        $current_movie = $1;
    }
    if ($current_movie =~ /^[^"].*$/ && $_ =~ /^( ?!\(TV\)) (?!\(V\)) (?!\(VG\)) .)*$/x)  {	#regex line 1: consume leading tabs and capture movie & date				        
        #regex line 2: assert there are no instances of "(TV)", "(V)", or "(VG)"
	my @array;        
	if (exists $moviesPresent{$current_actor}) {
    	  @array = @{$moviesPresent{$current_actor}};	
	}
        else {
	  @array = ();
	}
	push @array, $current_movie;
	$moviesPresent{$current_actor} = \@array;	
    }
  }
  $lastRef = \@movies;
  $moviesPresent{$current_actor} = $lastRef; 
}

buildGraph();

while(<>) {
  print "Actor/Actress? ";
  printNames(chomp($_));
}

# if two actors have at least one movie in common, put an edge between them (by adding to %connectedActors), then search another distinct pair (next) to see if they share a common movie
# builds %connectedActors
# helper: commonMovie
sub buildGraph {
  @actors = keys %moviesPresent;
  $offset = 1;
  for ($i = 0; $i < $#actors; $i++) {
    $firstAct = $actors[$i];
    @connected = ();
    @others = splice(@actors, $offset);
    foreach $secondAct (@others) {
      if (commonMovie($firstAct, $secondAct) {
        push @connect, $secondAct;
      }   	
    }
    $connectedActors{$firstAct} = \@connected;
    $offset++;
  } 
}

# get a common movie between the two given actors.
sub commonMovie {
  $firstAct = shift;
  $secondAct = shift;
  %hash = map {$_ -> 1} @{$moviesPresent{$secondAct}}; 
  foreach $movie (@{$moviesPresent{$firstAct}}) {
    if exists $hash{$movie} {
      return $movie;
    }
  }
  return "";
}

# print all relevant actors, based on the "keywords" typed in by the user
# if a specific actor is specified, call search
sub printNames {
}

# borrows from Dijkstra's algorithm to find all of the shortest paths from KB
sub findPaths {
  my @actQueue = ["Bacon, Kevin"];
  my @pathQueue = ["Bacon, Kevin"]; # these two lists should be synced together, that way we get the correct sub-path for each actor
  while (@actQueue && @pathQueue) {
    my $currentAct = shift @actQueue;
    my $currentPath = shift @pathQueue;
    foreach $neighbor (@{$connectActors{$currentAct}}) {
      if (!($neighbor =~ /#$/) {
        $copyPath = $currentPath;
        push @{$copyPath}, $neighbor;
        push @pathActors, $copyPath;
        push @actQueue, $neighbor;
        push @pathQueue, $copyPath;
        $neighbor += "#";
      }
    }
  }
}
 
sub search {
  foreach $path (@pathActors) { 
    if (${$path->[-1]} eq shift)
      return $path;
  }
  return "";
}

















































}


